#!/usr/bin/env python3
"""Telegram bot for figure price alerts.

Runs as a separate process from the scraper. Polls the pending_alerts
table and sends rich photo messages to subscribed users.

Run:
    python telegram_bot.py
"""

import asyncio
import logging
import sqlite3
from datetime import datetime, timedelta

from dotenv import load_dotenv
load_dotenv()

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ParseMode
from telegram.error import Forbidden, TimedOut, NetworkError
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
)

from config import (
    ALERT_STALE_HOURS,
    ALERT_SUMMARY_THRESHOLD,
    DASHBOARD_URL,
    DB_PATH,
    SITES,
    TELEGRAM_BOT_TOKEN,
)
from db import KST, get_connection, now_kst

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

# Alert type display config (Korean)
ALERT_TYPES = {
    "new":     {"label": "ğŸ†• ì‹ ê·œ ìƒí’ˆ",  "col": "alert_new"},
    "restock": {"label": "ğŸ”„ ì¬ì…ê³ ",     "col": "alert_restock"},
    "price":   {"label": "ğŸ’° ê°€ê²© ë³€ë™",  "col": "alert_price"},
    "soldout": {"label": "âŒ í’ˆì ˆ",       "col": "alert_soldout"},
}

# Site display names from config
SITE_NAMES = {k: v["display_name"] for k, v in SITES.items()}


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Database helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _get_or_create_user(conn: sqlite3.Connection, chat_id: int, username: str | None) -> dict:
    """Get existing user or create a new one. Returns user row as dict."""
    row = conn.execute(
        "SELECT * FROM telegram_users WHERE chat_id = ?", (chat_id,)
    ).fetchone()

    if row:
        # Reactivate if previously blocked
        if not row["is_active"]:
            conn.execute(
                "UPDATE telegram_users SET is_active = 1, updated_at = ? WHERE chat_id = ?",
                (now_kst(), chat_id),
            )
            conn.commit()
        return dict(conn.execute(
            "SELECT * FROM telegram_users WHERE chat_id = ?", (chat_id,)
        ).fetchone())

    now = now_kst()
    conn.execute(
        """INSERT INTO telegram_users (chat_id, username, created_at, updated_at)
           VALUES (?, ?, ?, ?)""",
        (chat_id, username, now, now),
    )
    conn.commit()
    return dict(conn.execute(
        "SELECT * FROM telegram_users WHERE chat_id = ?", (chat_id,)
    ).fetchone())


def _toggle_alert(conn: sqlite3.Connection, chat_id: int, alert_type: str) -> bool:
    """Toggle an alert type for a user. Returns new value."""
    col = ALERT_TYPES[alert_type]["col"]
    conn.execute(
        f"UPDATE telegram_users SET {col} = NOT {col}, updated_at = ? WHERE chat_id = ?",
        (now_kst(), chat_id),
    )
    conn.commit()
    row = conn.execute(
        f"SELECT {col} FROM telegram_users WHERE chat_id = ?", (chat_id,)
    ).fetchone()
    return bool(row[col])


def _get_active_users_for_type(conn: sqlite3.Connection, change_type: str) -> list[int]:
    """Get chat_ids of active users who want this alert type."""
    col = ALERT_TYPES.get(change_type, {}).get("col")
    if not col:
        return []
    rows = conn.execute(
        f"SELECT chat_id FROM telegram_users WHERE is_active = 1 AND {col} = 1"
    ).fetchall()
    return [r["chat_id"] for r in rows]


def _deactivate_user(conn: sqlite3.Connection, chat_id: int):
    """Mark user as inactive (blocked the bot)."""
    conn.execute(
        "UPDATE telegram_users SET is_active = 0, updated_at = ? WHERE chat_id = ?",
        (now_kst(), chat_id),
    )
    conn.commit()
    logger.info(f"Deactivated user {chat_id} (blocked bot)")


def _get_cross_site_prices(conn: sqlite3.Connection, product_db_id: int) -> list[dict]:
    """Get prices from other sites for the same product via matching groups."""
    row = conn.execute(
        "SELECT match_key FROM product_matches WHERE product_id = ?",
        (product_db_id,),
    ).fetchone()
    if not row:
        return []

    matches = conn.execute("""
        SELECT p.site, p.name, p.price, p.status, p.url
        FROM product_matches pm
        JOIN products p ON pm.product_id = p.id
        WHERE pm.match_key = ? AND pm.product_id != ?
        ORDER BY p.price ASC NULLS LAST
    """, (row["match_key"], product_db_id)).fetchall()
    return [dict(m) for m in matches]


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Alert formatting
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _format_price(price: int | None) -> str:
    if price is None:
        return "ê°€ê²© ë¯¸ì •"
    return f"â‚©{price:,}"


def _format_alert_caption(alert: dict, cross_prices: list[dict]) -> str:
    """Format an alert into an HTML caption for Telegram."""
    change_type = alert["change_type"]
    header = ALERT_TYPES.get(change_type, {}).get("label", change_type)
    site_name = SITE_NAMES.get(alert["site"], alert["site"])

    lines = [f"{header}\n"]
    lines.append(f"<b>{_escape_html(alert['product_name'])}</b>\n")

    if change_type == "price":
        old_p = int(alert["old_value"]) if alert["old_value"] else None
        new_p = int(alert["new_value"]) if alert["new_value"] else None
        if old_p and new_p:
            pct = (new_p - old_p) / old_p * 100
            sign = "+" if pct > 0 else ""
            lines.append(f"ğŸ’° {_format_price(old_p)} â†’ {_format_price(new_p)} ({sign}{pct:.0f}%)")
        else:
            lines.append(f"ğŸ’° {_format_price(alert['product_price'])}")
    else:
        lines.append(f"ğŸ’° {_format_price(alert['product_price'])}")

    lines.append(f"ğŸª {site_name}")

    if change_type == "new" and alert.get("new_value"):
        status_map = {"available": "êµ¬ë§¤ ê°€ëŠ¥", "preorder": "ì˜ˆì•½ì¤‘", "soldout": "í’ˆì ˆ"}
        status_kr = status_map.get(alert["new_value"], alert["new_value"])
        lines.append(f"ğŸ“¦ {status_kr}")

    # Cross-site prices
    if cross_prices:
        lines.append(f"\nğŸ”— <b>ë‹¤ë¥¸ ì‚¬ì´íŠ¸ ê°€ê²©:</b>")
        for cp in cross_prices[:4]:  # Max 4 to stay under caption limit
            cp_site = SITE_NAMES.get(cp["site"], cp["site"])
            cp_price = _format_price(cp["price"])
            lines.append(f" Â· {cp_site}: {cp_price}")

    return "\n".join(lines)


def _format_summary(alerts: list[dict]) -> str:
    """Format a batch summary header message."""
    counts = {}
    for a in alerts:
        ct = a["change_type"]
        counts[ct] = counts.get(ct, 0) + 1

    lines = ["ğŸ“Š <b>í”¼ê·œì–´ ì•Œë¦¼ ìš”ì•½</b>\n"]
    for ct, info in ALERT_TYPES.items():
        if ct in counts:
            lines.append(f"{info['label']}: {counts[ct]}ê°œ")
    lines.append("\nì•„ë˜ì—ì„œ ìƒì„¸ ë‚´ìš©ì„ í™•ì¸í•˜ì„¸ìš”.")
    return "\n".join(lines)


def _build_alert_keyboard(alert: dict) -> InlineKeyboardMarkup | None:
    """Build inline keyboard buttons for an alert message."""
    buttons = []
    if alert.get("product_url"):
        buttons.append(InlineKeyboardButton("ğŸ”— ìƒí’ˆ ë³´ê¸°", url=alert["product_url"]))
    if DASHBOARD_URL:
        buttons.append(InlineKeyboardButton("ğŸ“Š ëŒ€ì‹œë³´ë“œ", url=DASHBOARD_URL))
    if not buttons:
        return None
    return InlineKeyboardMarkup([buttons])


def _escape_html(text: str) -> str:
    """Escape HTML special characters for Telegram HTML parse mode."""
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Settings keyboard
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _build_settings_keyboard(user: dict) -> InlineKeyboardMarkup:
    """Build inline keyboard for alert settings toggles."""
    buttons = []
    for alert_type, info in ALERT_TYPES.items():
        col = info["col"]
        is_on = user.get(col, False)
        emoji = "âœ…" if is_on else "âŒ"
        label = f"{info['label']}: {emoji}"
        buttons.append([InlineKeyboardButton(label, callback_data=f"toggle_{alert_type}")])
    return InlineKeyboardMarkup(buttons)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Command handlers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /start â€” register user and show welcome."""
    conn = get_connection()
    user = _get_or_create_user(
        conn,
        update.effective_chat.id,
        update.effective_user.username,
    )
    conn.close()

    keyboard = _build_settings_keyboard(user)
    await update.message.reply_text(
        "ğŸ‘‹ <b>í”¼ê·œì–´ ì•Œë¦¼ ë´‡ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!</b>\n\n"
        "5ê°œ ì‚¬ì´íŠ¸ì˜ í”¼ê·œì–´ ì‹ ê·œ ìƒí’ˆ, ì¬ì…ê³ , ê°€ê²© ë³€ë™ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n"
        "ğŸ“Œ <b>í˜„ì¬ ì•Œë¦¼ ì„¤ì •:</b>",
        parse_mode=ParseMode.HTML,
        reply_markup=keyboard,
    )


async def cmd_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /settings â€” show alert toggle keyboard."""
    conn = get_connection()
    user = _get_or_create_user(
        conn,
        update.effective_chat.id,
        update.effective_user.username,
    )
    conn.close()

    keyboard = _build_settings_keyboard(user)
    await update.message.reply_text(
        "âš™ï¸ <b>ì•Œë¦¼ ì„¤ì •</b>\n\në²„íŠ¼ì„ ëˆŒëŸ¬ ì•Œë¦¼ì„ ì¼œê±°ë‚˜ ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        parse_mode=ParseMode.HTML,
        reply_markup=keyboard,
    )


async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /help â€” show available commands."""
    await update.message.reply_text(
        "ğŸ“– <b>ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´</b>\n\n"
        "/start â€” ë´‡ ì‹œì‘ ë° ë“±ë¡\n"
        "/settings â€” ì•Œë¦¼ ì„¤ì • ë³€ê²½\n"
        "/status â€” ë´‡ í˜„í™© í™•ì¸\n"
        "/help â€” ì´ ë„ì›€ë§ ë³´ê¸°",
        parse_mode=ParseMode.HTML,
    )


async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /status â€” show bot stats."""
    conn = get_connection()

    product_count = conn.execute("SELECT COUNT(*) FROM products").fetchone()[0]
    site_count = conn.execute("SELECT COUNT(DISTINCT site) FROM products").fetchone()[0]
    user_count = conn.execute(
        "SELECT COUNT(*) FROM telegram_users WHERE is_active = 1"
    ).fetchone()[0]
    last_alert = conn.execute(
        "SELECT MAX(created_at) FROM pending_alerts"
    ).fetchone()[0]

    conn.close()

    await update.message.reply_text(
        "ğŸ“Š <b>ë´‡ í˜„í™©</b>\n\n"
        f"ğŸ“¦ ì¶”ì  ì¤‘ì¸ ìƒí’ˆ: {product_count:,}ê°œ\n"
        f"ğŸª ëª¨ë‹ˆí„°ë§ ì‚¬ì´íŠ¸: {site_count}ê°œ\n"
        f"ğŸ‘¤ í™œì„± ì‚¬ìš©ì: {user_count}ëª…\n"
        f"ğŸ• ë§ˆì§€ë§‰ ì•Œë¦¼: {last_alert or 'ì—†ìŒ'}",
        parse_mode=ParseMode.HTML,
    )


async def callback_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle settings toggle button press."""
    query = update.callback_query
    await query.answer()

    data = query.data
    if not data or not data.startswith("toggle_"):
        return

    alert_type = data.replace("toggle_", "")
    if alert_type not in ALERT_TYPES:
        return

    conn = get_connection()
    _toggle_alert(conn, update.effective_chat.id, alert_type)
    user = dict(conn.execute(
        "SELECT * FROM telegram_users WHERE chat_id = ?",
        (update.effective_chat.id,),
    ).fetchone())
    conn.close()

    keyboard = _build_settings_keyboard(user)
    await query.edit_message_reply_markup(reply_markup=keyboard)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Alert dispatcher (runs on job queue)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def process_pending_alerts(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Poll pending_alerts and send to matching users."""
    conn = get_connection()

    # Check for stale backlog (bot was offline)
    oldest = conn.execute(
        "SELECT MIN(created_at) FROM pending_alerts WHERE sent_at IS NULL"
    ).fetchone()[0]

    if oldest:
        stale_cutoff = (datetime.now(KST) - timedelta(hours=ALERT_STALE_HOURS)).strftime("%Y-%m-%d %H:%M:%S")

        if oldest < stale_cutoff:
            # Summarize stale alerts instead of flooding
            stale_alerts = conn.execute(
                "SELECT change_type, COUNT(*) as cnt FROM pending_alerts WHERE sent_at IS NULL GROUP BY change_type"
            ).fetchall()

            total = sum(r["cnt"] for r in stale_alerts)
            lines = ["â° <b>ë´‡ì´ ì˜¤í”„ë¼ì¸ ë™ì•ˆì˜ ì•Œë¦¼ ìš”ì•½</b>\n"]
            for r in stale_alerts:
                info = ALERT_TYPES.get(r["change_type"], {})
                label = info.get("label", r["change_type"])
                lines.append(f"{label}: {r['cnt']}ê°œ")
            lines.append(f"\nì´ {total}ê°œì˜ ì•Œë¦¼ì´ ìˆì—ˆìŠµë‹ˆë‹¤.")
            summary_text = "\n".join(lines)

            # Send to all active users
            users = conn.execute(
                "SELECT chat_id FROM telegram_users WHERE is_active = 1"
            ).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(
                        chat_id=user["chat_id"],
                        text=summary_text,
                        parse_mode=ParseMode.HTML,
                    )
                except Forbidden:
                    _deactivate_user(conn, user["chat_id"])
                except Exception as e:
                    logger.warning(f"Failed to send stale summary to {user['chat_id']}: {e}")

            # Mark all stale as sent
            conn.execute(
                "UPDATE pending_alerts SET sent_at = ? WHERE sent_at IS NULL",
                (now_kst(),),
            )
            conn.commit()
            conn.close()
            logger.info(f"Sent stale backlog summary ({total} alerts)")
            return

    # Normal processing: get unsent alerts grouped by batch
    unsent = conn.execute("""
        SELECT * FROM pending_alerts
        WHERE sent_at IS NULL
        ORDER BY batch_id, id
    """).fetchall()

    if not unsent:
        conn.close()
        return

    unsent = [dict(r) for r in unsent]

    # Group by batch_id
    batches: dict[str, list[dict]] = {}
    for alert in unsent:
        batches.setdefault(alert["batch_id"], []).append(alert)

    sent_count = 0

    for batch_id, alerts in batches.items():
        # Collect all unique change types in this batch
        change_types = set(a["change_type"] for a in alerts)

        # Get all users who should receive at least one alert type
        type_to_users: dict[str, list[int]] = {}
        for ct in change_types:
            type_to_users[ct] = _get_active_users_for_type(conn, ct)

        # All users who get any alert in this batch
        all_users = set()
        for users in type_to_users.values():
            all_users.update(users)

        if not all_users:
            # No users want any of these â€” mark as sent
            for alert in alerts:
                conn.execute(
                    "UPDATE pending_alerts SET sent_at = ? WHERE id = ?",
                    (now_kst(), alert["id"]),
                )
            conn.commit()
            continue

        # Send summary header if batch is large enough
        if len(alerts) >= ALERT_SUMMARY_THRESHOLD:
            summary = _format_summary(alerts)
            for chat_id in all_users:
                try:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=summary,
                        parse_mode=ParseMode.HTML,
                    )
                    await asyncio.sleep(0.05)
                except Forbidden:
                    _deactivate_user(conn, chat_id)
                except Exception as e:
                    logger.warning(f"Failed to send summary to {chat_id}: {e}")

        # Send individual alerts
        for alert in alerts:
            target_users = type_to_users.get(alert["change_type"], [])
            if not target_users:
                conn.execute(
                    "UPDATE pending_alerts SET sent_at = ? WHERE id = ?",
                    (now_kst(), alert["id"]),
                )
                continue

            cross_prices = _get_cross_site_prices(conn, alert["product_db_id"])
            caption = _format_alert_caption(alert, cross_prices)
            keyboard = _build_alert_keyboard(alert)

            for chat_id in target_users:
                try:
                    if alert.get("image_url"):
                        await context.bot.send_photo(
                            chat_id=chat_id,
                            photo=alert["image_url"],
                            caption=caption,
                            parse_mode=ParseMode.HTML,
                            reply_markup=keyboard,
                        )
                    else:
                        await context.bot.send_message(
                            chat_id=chat_id,
                            text=caption,
                            parse_mode=ParseMode.HTML,
                            reply_markup=keyboard,
                        )
                    await asyncio.sleep(0.05)
                except Forbidden:
                    _deactivate_user(conn, chat_id)
                except (TimedOut, NetworkError) as e:
                    # Retry once after short delay
                    logger.warning(f"Transient error sending to {chat_id}, retrying: {e}")
                    await asyncio.sleep(5)
                    try:
                        await context.bot.send_message(
                            chat_id=chat_id,
                            text=caption,
                            parse_mode=ParseMode.HTML,
                            reply_markup=keyboard,
                        )
                    except Exception:
                        logger.warning(f"Retry failed for {chat_id}")
                except Exception as e:
                    # sendPhoto may fail if CDN blocks Telegram â€” fallback to text
                    if alert.get("image_url"):
                        try:
                            await context.bot.send_message(
                                chat_id=chat_id,
                                text=caption,
                                parse_mode=ParseMode.HTML,
                                reply_markup=keyboard,
                            )
                        except Exception:
                            logger.warning(f"Text fallback also failed for {chat_id}: {e}")
                    else:
                        logger.warning(f"Failed to send alert to {chat_id}: {e}")

            # Mark alert as sent
            conn.execute(
                "UPDATE pending_alerts SET sent_at = ? WHERE id = ?",
                (now_kst(), alert["id"]),
            )
            sent_count += 1

        conn.commit()

    conn.close()
    if sent_count:
        logger.info(f"Sent {sent_count} alerts")


async def cleanup_old_alerts(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Delete old sent alerts to keep the table small."""
    conn = get_connection()
    result = conn.execute(
        "DELETE FROM pending_alerts WHERE sent_at IS NOT NULL AND created_at < datetime('now', '+9 hours', '-7 days')"
    )
    deleted = result.rowcount
    conn.commit()
    conn.close()
    if deleted:
        logger.info(f"Cleaned up {deleted} old alerts")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    if not TELEGRAM_BOT_TOKEN:
        print("ERROR: TELEGRAM_BOT_TOKEN not set in .env")
        return

    # Ensure DB tables exist
    from db import init_db
    init_db()

    app = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Command handlers
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("settings", cmd_settings))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CommandHandler("status", cmd_status))

    # Callback handler for settings toggles
    app.add_handler(CallbackQueryHandler(callback_toggle, pattern="^toggle_"))

    # Job queue: poll pending alerts every 30 seconds
    app.job_queue.run_repeating(
        process_pending_alerts,
        interval=30,
        first=10,  # Start 10s after boot to let things settle
        name="alert_dispatcher",
    )

    # Job queue: clean up old alerts daily
    app.job_queue.run_repeating(
        cleanup_old_alerts,
        interval=86400,  # 24 hours
        first=3600,      # First run 1 hour after start
        name="alert_cleanup",
    )

    logger.info("Telegram bot starting... (polling every 30s for alerts)")
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
